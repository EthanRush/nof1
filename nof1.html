<!DOCTYPE html>
<!-- saved from url=(0051)https://threejs.org/examples/webgl_gpgpu_birds.html -->
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>NOF1</title>

    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="./main.css" />
    <link type="text/css" rel="stylesheet" href="./mobilemain.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <!-- <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"> -->
    <style>
      * {
        font-family: "Helvetica";
        font-weight: 500;
      }
      body {
        background-color: #fff;
        color: #444;
      }
      a {
        color: #08f;
      }
      span,
      p,
      ul {
        font-size: 2rem;
        line-height: 1.2;
      }
      h2 {
        font-size: 96px;
        line-height: normal;
      }
    </style>
    <style type="text/css">
      @font-face {
        font-weight: 400;
        font-style: normal;
        font-family: Mont;

        src: url("chrome-extension://liecbddmkiiihnedobmlmillhodjkdmb/fonts/CircularXXWeb-Book.woff2")
          format("woff2");
      }

      @font-face {
        font-weight: 700;
        font-style: normal;
        font-family: circular;

        src: url("chrome-extension://liecbddmkiiihnedobmlmillhodjkdmb/fonts/CircularXXWeb-Bold.woff2")
          format("woff2");
      }
    </style>
  </head>
  <body cz-shortcut-listen="true">
    <div id="nav-dots" class="desktop-only">
      <div class="dot-wrap about">
        <a href="#About" onclick="proceedLoop(false);navdot('1')">
          <span class="dot-text">About</span>
          <span class="dot">&#x2022;</span>
        </a>
      </div>
      <div class="dot-wrap testimonials">
        <a href="#Testimonials" onclick="proceedLoop(true);navdot('2')">
          <span class="dot-text">Testimonials</span>
          <span class="dot">&#x2022;</span>
        </a>
      </div>
      <!-- <div class="dot-wrap projects">
				<a href="#Projects">
				<span class="dot-text">Projects</span>
				<span class="dot">&#x2022;</span>
				</a>
			</div> -->
      <div class="dot-wrap talk">
        <a href="#Talk" onclick="proceedLoop(false);navdot('6')">
          <span class="dot-text">Let's Talk</span>
          <span class="dot">&#x2022;</span>
        </a>
      </div>
    </div>
    <div id="mobile-nav-dots" class="mobile-only">
      <div class="dot-wrap about">
        <a href="#About" onclick="proceedLoop(false);navdot('1')">
          <span class="dot">&#x2022;</span>
        </a>
      </div>
      <div class="dot-wrap testimonials">
        <a href="#Testimonials" onclick="proceedLoop(true);navdot('2')">
          <span class="dot">&#x2022;</span>
        </a>
      </div>
      <!-- <div class="dot-wrap projects">
				<a href="#Projects">
				<span class="dot-text">Projects</span>
				<span class="dot">&#x2022;</span>
				</a>
			</div> -->
      <div class="dot-wrap talk">
        <a href="#Talk" onclick="proceedLoop(false);navdot('6')">
          <span class="dot">&#x2022;</span>
        </a>
      </div>
    </div>
    <div class="mobile-only mobile-headers">
      <h3 id="mobileAbout">About</h3>
      <h3 id="mobileTestimonials">Testimonials</h3>
      <h3 id="mobileTalk">Talk</h3>
    </div>
    <div class="logo" style="text-align: center; align-content: center">
      <img class="main-logo" src="./assets/nof1Cropped.png" />
      <div id="ticker-container">
        <div id="ticker">
          <p class="new-text-section blank"></p>
          <p class="new-text-section">
            N of 1 is a design studio led by Chatham Sullivan specializing in
            <span class="bold"> people innovation.</span>
            Our mission is to bring the same bold, creative problem-solving and
            high-impact design typically reserved for groundbreaking products
            and services in the market to the heart of every organization: its
            people.
          </p>

          <p class="new-text-section">
            "Working with
            Chatham is like opening a door that you were always curious about
            but just assumed was permanently locked. Don't be surprised if the
            world around you no longer looks like it once did."
            <br><br>
            <span>- Neil Alger, Head of Talent Development
              <span class="bold"> Google School</span> for Leaders</span>
          </p>

          <p class="new-text-section">
            "I was shown it under conditions of inviolable secrecy, but they had
            spotted things about us so quickly and astutely, I was stunningly
            impressed. I thought the work was utterly fabulous."
            <br><br>
            <span>- Rory Sutherland, Vice Chairman
              <span class="bold"> Ogilvy</span></span>
          </p>

          <p class="new-text-section">
            "The insights I gleaned from our work were transformational. To say
            that Chatham challenged my dominant thinking and inspired my team to
            step into an entirely new set of possibilities is a massive
            understatement. The takeaways are actively shaping how we're
            reframing our whole scale initiative."
            <br><br>
            <span>- Christina Wire, VP Global Operations<span class="bold">
              YouTube</span
            ></span>
          </p>

          <p class="new-text-section">
            
            "Chatham is not a traditional consultant, but a transformative
            guide. He has helped reframe my way of thinking around work to be
            product-centric and obsessively focused on our people's experience.
            There is no one better equipped to help individuals and companies to
            find their way."
            <br><br>
            <span>- Michael Ehret, Head of Global Talent</span
              ><span class="bold"> Johnson & Johnson</span>
          </p>

          <p class="new-text-section final">
            If you're looking for a fast-moving partner who prioritizes action
            and progress over slides and roadmaps, an alternative to the canned
            solutions of big firms, a partner with charisma who speaks honestly
            without fear or favor, and someone who values quality and impact
            over checking the box... <a
            href="https://www.linkedin.com/in/chatham-sullivan-3519b370"
            target="_blank"
            >LET'S TALK</a
          >
          </p>


          
        </div>
      </div>
    </div>

    <!--
		TODO: If you're reading this, you may wish to improve this example by
			- Create a better shading for the birds?

		-->

    <!-- shader for bird's position -->
    <script id="fragmentShaderPosition" type="x-shader/x-fragment">

      uniform float time;
      uniform float delta;

      void main()	{

      	vec2 uv = gl_FragCoord.xy / resolution.xy;
      	vec4 tmpPos = texture2D( texturePosition, uv );
      	vec3 position = tmpPos.xyz;
      	vec3 velocity = texture2D( textureVelocity, uv ).xyz;

      	float phase = tmpPos.w;

      	phase = mod( ( phase + delta +
      		length( velocity.xz ) * delta * 3. +
      		max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );

      	gl_FragColor = vec4( position + velocity * delta * 15. , phase );

      }
    </script>

    <!-- shader for bird's velocity -->
    <script id="fragmentShaderVelocity" type="x-shader/x-fragment">

      uniform float time;
      uniform float testing;
      uniform float delta; // about 0.016
      uniform float separationDistance; // 20
      uniform float alignmentDistance; // 40
      uniform float cohesionDistance; //
      uniform float freedomFactor;
      uniform vec3 predator;

      const float width = resolution.x;
      const float height = resolution.y;

      const float PI = 3.141592653589793;
      const float PI_2 = PI * 2.0;
      // const float VISION = PI * 0.55;

      float zoneRadius = 40.0;
      float zoneRadiusSquared = 1600.0;

      float separationThresh = 0.45;
      float alignmentThresh = 0.65;

      const float UPPER_BOUNDS = BOUNDS;
      const float LOWER_BOUNDS = -UPPER_BOUNDS;

      const float SPEED_LIMIT = 5.0;

      float rand( vec2 co ){
      	return fract( sin( dot( co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );
      }

      void main() {

      	zoneRadius = separationDistance + alignmentDistance + cohesionDistance;
      	separationThresh = separationDistance / zoneRadius;
      	alignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;
      	zoneRadiusSquared = zoneRadius * zoneRadius;


      	vec2 uv = gl_FragCoord.xy / resolution.xy;
      	vec3 birdPosition, birdVelocity;

      	vec3 selfPosition = texture2D( texturePosition, uv ).xyz;
      	vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;

      	float dist;
      	vec3 dir; // direction
      	float distSquared;

      	float separationSquared = separationDistance * separationDistance;
      	float cohesionSquared = cohesionDistance * cohesionDistance;

      	float f;
      	float percent;

      	vec3 velocity = selfVelocity;

      	float limit = SPEED_LIMIT;

      	dir = predator * UPPER_BOUNDS - selfPosition;
      	dir.z = 0.;
      	// dir.z *= 0.6;
      	dist = length( dir );
      	distSquared = dist * dist;

      	float preyRadius = 150.0;
      	float preyRadiusSq = preyRadius * preyRadius;


      	// move birds away from predator
      	if ( dist < preyRadius ) {

      		f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;
      		velocity -= normalize( dir ) * f;
      		limit += 5.0;
      	}


      	// if (testing == 0.0) {}
      	// if ( rand( uv + time ) < freedomFactor ) {}


      	// Attract flocks to the center
      	vec3 central = vec3( 0., 0., 0. );
      	dir = selfPosition - central;
      	dist = length( dir );

      	dir.y *= 2.5;
      	velocity -= normalize( dir ) * delta * 5.;

      	for ( float y = 0.0; y < height; y++ ) {
      		for ( float x = 0.0; x < width; x++ ) {

      			vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;
      			birdPosition = texture2D( texturePosition, ref ).xyz;

      			dir = birdPosition - selfPosition;
      			dist = length( dir );

      			if ( dist < 0.0001 ) continue;

      			distSquared = dist * dist;

      			if ( distSquared > zoneRadiusSquared ) continue;

      			percent = distSquared / zoneRadiusSquared;

      			if ( percent < separationThresh ) { // low

      				// Separation - Move apart for comfort
      				f = ( separationThresh / percent - 1.0 ) * delta;
      				velocity -= normalize( dir ) * f;

      			} else if ( percent < alignmentThresh ) { // high

      				// Alignment - fly the same direction
      				float threshDelta = alignmentThresh - separationThresh;
      				float adjustedPercent = ( percent - separationThresh ) / threshDelta;

      				birdVelocity = texture2D( textureVelocity, ref ).xyz;

      				f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;
      				velocity += normalize( birdVelocity ) * f;

      			} else {

      				// Attraction / Cohesion - move closer
      				float threshDelta = 1.0 - alignmentThresh;
      				float adjustedPercent;
      				if( threshDelta == 0. ) adjustedPercent = 1.;
      				else adjustedPercent = ( percent - alignmentThresh ) / threshDelta;

      				f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;

      				velocity += normalize( dir ) * f;

      			}

      		}

      	}



      	// this make tends to fly around than down or up
      	// if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);

      	// Speed Limits
      	if ( length( velocity ) > limit ) {
      		velocity = normalize( velocity ) * limit;
      	}

      	gl_FragColor = vec4( velocity, 1.0 );

      }
    </script>

    <script type="x-shader/x-vertex" id="birdVS">

      attribute vec2 reference;
      attribute float birdVertex;

      attribute vec3 birdColor;

      uniform sampler2D texturePosition;
      uniform sampler2D textureVelocity;

      varying vec4 vColor;
      varying float z;

      uniform float time;

      void main() {

      	vec4 tmpPos = texture2D( texturePosition, reference );
      	vec3 pos = tmpPos.xyz;
      	vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);

      	vec3 newPosition = position;

      	if ( birdVertex == 4.0 || birdVertex == 7.0 ) {
      		// flap wings
      		newPosition.y = sin( tmpPos.w ) * 5.;
      	}

      	newPosition = mat3( modelMatrix ) * newPosition;


      	velocity.z *= -1.;
      	float xz = length( velocity.xz );
      	float xyz = 1.;
      	float x = sqrt( 1. - velocity.y * velocity.y );

      	float cosry = velocity.x / xz;
      	float sinry = velocity.z / xz;

      	float cosrz = x / xyz;
      	float sinrz = velocity.y / xyz;

      	mat3 maty =  mat3(
      		cosry, 0, -sinry,
      		0    , 1, 0     ,
      		sinry, 0, cosry

      	);

      	mat3 matz =  mat3(
      		cosrz , sinrz, 0,
      		-sinrz, cosrz, 0,
      		0     , 0    , 1
      	);

      	newPosition =  maty * matz * newPosition;
      	newPosition += pos;

      	z = newPosition.z;

      	vColor = vec4( birdColor, 1.0 );
      	gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );
      }
    </script>

    <!-- bird geometry shader -->
    <script type="x-shader/x-fragment" id="birdFS">

      varying vec4 vColor;
      varying float z;

      uniform vec3 color;

      void main() {
      	// Fake colors for now
      	float z2 = 0.2 + ( 1000. - z ) / 1000. * vColor.x;
      	gl_FragColor = vec4( z2, z2, z2, 1. );

      }
    </script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import { GPUComputationRenderer } from "three/addons/misc/GPUComputationRenderer.js";

      /* TEXTURE WIDTH FOR SIMULATION */
      const WIDTH = 32;

      const BIRDS = WIDTH * WIDTH;

      // Custom Geometry - using 3 triangles each. No UVs, no normals currently.
      class BirdGeometry extends THREE.BufferGeometry {
        constructor() {
          super();

          const trianglesPerBird = 3;
          const triangles = BIRDS * trianglesPerBird;
          const points = triangles * 3;

          const vertices = new THREE.BufferAttribute(
            new Float32Array(points * 3),
            3
          );
          const birdColors = new THREE.BufferAttribute(
            new Float32Array(points * 3),
            3
          );
          const references = new THREE.BufferAttribute(
            new Float32Array(points * 2),
            2
          );
          const birdVertex = new THREE.BufferAttribute(
            new Float32Array(points),
            1
          );

          this.setAttribute("position", vertices);
          this.setAttribute("birdColor", birdColors);
          this.setAttribute("reference", references);
          this.setAttribute("birdVertex", birdVertex);

          // this.setAttribute( 'normal', new Float32Array( points * 3 ), 3 );

          let v = 0;

          function verts_push() {
            for (let i = 0; i < arguments.length; i++) {
              vertices.array[v++] = arguments[i];
            }
          }

          const wingsSpan = 20;

          for (let f = 0; f < BIRDS; f++) {
            // Body

            verts_push(0, -0, -20, 0, 4, -20, 0, 0, 30);

            // Wings

            verts_push(0, 0, -15, -wingsSpan, 0, 0, 0, 0, 15);

            verts_push(0, 0, 15, wingsSpan, 0, 0, 0, 0, -15);
          }

          for (let v = 0; v < triangles * 3; v++) {
            const triangleIndex = ~~(v / 3);
            const birdIndex = ~~(triangleIndex / trianglesPerBird);
            const x = (birdIndex % WIDTH) / WIDTH;
            const y = ~~(birdIndex / WIDTH) / WIDTH;

            const c = new THREE.Color(
              0x666666 + (~~(v / 9) / BIRDS) * 0x666666
            );

            birdColors.array[v * 3 + 0] = c.r;
            birdColors.array[v * 3 + 1] = c.g;
            birdColors.array[v * 3 + 2] = c.b;

            references.array[v * 2] = x;
            references.array[v * 2 + 1] = y;

            birdVertex.array[v] = v % 9;
          }

          this.scale(0.2, 0.2, 0.2);
        }
      }

      //

      let container;
      let camera, scene, renderer;
      let mouseX = 0,
        mouseY = 0;

      let windowHalfX = window.innerWidth / 2;
      let windowHalfY = window.innerHeight / 2;

      const BOUNDS = 800,
        BOUNDS_HALF = BOUNDS / 2;

      let last = performance.now();

      let gpuCompute;
      let velocityVariable;
      let positionVariable;
      let positionUniforms;
      let velocityUniforms;
      let birdUniforms;

      init();

      function init() {
        container = document.createElement("div");
        container.id = "webgl-container";
        document.body.prepend(container);

        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          1,
          3000
        );
        camera.position.z = 350;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        scene.fog = new THREE.Fog(0xffffff, 100, 1000);

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        container.appendChild(renderer.domElement);

        initComputeRenderer();

        container.style.touchAction = "none";
        container.addEventListener("pointermove", onPointerMove);

        //

        window.addEventListener("resize", onWindowResize);

        //const gui = new GUI();

        const effectController = {
          separation: 20.0,
          alignment: 20.0,
          cohesion: 20.0,
          freedom: 0.75,
        };

        const valuesChanger = function () {
          velocityUniforms["separationDistance"].value =
            effectController.separation;
          velocityUniforms["alignmentDistance"].value =
            effectController.alignment;
          velocityUniforms["cohesionDistance"].value =
            effectController.cohesion;
          velocityUniforms["freedomFactor"].value = effectController.freedom;
        };

        valuesChanger();

        /*gui.add( effectController, 'separation', 0.0, 100.0, 1.0 ).onChange( valuesChanger );
				gui.add( effectController, 'alignment', 0.0, 100, 0.001 ).onChange( valuesChanger );
				gui.add( effectController, 'cohesion', 0.0, 100, 0.025 ).onChange( valuesChanger );
				gui.close();*/

        initBirds();
      }

      function initComputeRenderer() {
        gpuCompute = new GPUComputationRenderer(WIDTH, WIDTH, renderer);

        const dtPosition = gpuCompute.createTexture();
        const dtVelocity = gpuCompute.createTexture();
        fillPositionTexture(dtPosition);
        fillVelocityTexture(dtVelocity);

        velocityVariable = gpuCompute.addVariable(
          "textureVelocity",
          document.getElementById("fragmentShaderVelocity").textContent,
          dtVelocity
        );
        positionVariable = gpuCompute.addVariable(
          "texturePosition",
          document.getElementById("fragmentShaderPosition").textContent,
          dtPosition
        );

        gpuCompute.setVariableDependencies(velocityVariable, [
          positionVariable,
          velocityVariable,
        ]);
        gpuCompute.setVariableDependencies(positionVariable, [
          positionVariable,
          velocityVariable,
        ]);

        positionUniforms = positionVariable.material.uniforms;
        velocityUniforms = velocityVariable.material.uniforms;

        positionUniforms["time"] = { value: 0.0 };
        positionUniforms["delta"] = { value: 0.0 };
        velocityUniforms["time"] = { value: 1.0 };
        velocityUniforms["delta"] = { value: 0.0 };
        velocityUniforms["testing"] = { value: 1.0 };
        velocityUniforms["separationDistance"] = { value: 1.0 };
        velocityUniforms["alignmentDistance"] = { value: 1.0 };
        velocityUniforms["cohesionDistance"] = { value: 1.0 };
        velocityUniforms["freedomFactor"] = { value: 1.0 };
        velocityUniforms["predator"] = { value: new THREE.Vector3() };
        velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed(2);

        velocityVariable.wrapS = THREE.RepeatWrapping;
        velocityVariable.wrapT = THREE.RepeatWrapping;
        positionVariable.wrapS = THREE.RepeatWrapping;
        positionVariable.wrapT = THREE.RepeatWrapping;

        const error = gpuCompute.init();

        if (error !== null) {
          console.error(error);
        }
      }

      function initBirds() {
        const geometry = new BirdGeometry();

        // For Vertex and Fragment
        birdUniforms = {
          color: { value: new THREE.Color(0xff2200) },
          texturePosition: { value: null },
          textureVelocity: { value: null },
          time: { value: 1.0 },
          delta: { value: 0.0 },
        };

        // THREE.ShaderMaterial
        const material = new THREE.ShaderMaterial({
          uniforms: birdUniforms,
          vertexShader: document.getElementById("birdVS").textContent,
          fragmentShader: document.getElementById("birdFS").textContent,
          side: THREE.DoubleSide,
        });

        const birdMesh = new THREE.Mesh(geometry, material);
        birdMesh.rotation.y = Math.PI / 2;
        birdMesh.matrixAutoUpdate = false;
        birdMesh.updateMatrix();

        scene.add(birdMesh);
      }

      function fillPositionTexture(texture) {
        const theArray = texture.image.data;

        for (let k = 0, kl = theArray.length; k < kl; k += 4) {
          const x = Math.random() * BOUNDS - BOUNDS_HALF;
          const y = Math.random() * BOUNDS - BOUNDS_HALF;
          const z = Math.random() * BOUNDS - BOUNDS_HALF;

          theArray[k + 0] = x;
          theArray[k + 1] = y;
          theArray[k + 2] = z;
          theArray[k + 3] = 1;
        }
      }

      function fillVelocityTexture(texture) {
        const theArray = texture.image.data;

        for (let k = 0, kl = theArray.length; k < kl; k += 4) {
          const x = Math.random() - 0.5;
          const y = Math.random() - 0.5;
          const z = Math.random() - 0.5;

          theArray[k + 0] = x * 10;
          theArray[k + 1] = y * 10;
          theArray[k + 2] = z * 10;
          theArray[k + 3] = 1;
        }
      }

      function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onPointerMove(event) {
        if (event.isPrimary === false) return;

        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }

      //

      function animate() {
        render();
      }

      function render() {
        const now = performance.now();
        let delta = (now - last) / 1000;

        if (delta > 1) delta = 1; // safety cap on large deltas
        last = now;

        positionUniforms["time"].value = now;
        positionUniforms["delta"].value = delta;
        velocityUniforms["time"].value = now;
        velocityUniforms["delta"].value = delta;
        birdUniforms["time"].value = now;
        birdUniforms["delta"].value = delta;

        velocityUniforms["predator"].value.set(
          (0.5 * mouseX) / windowHalfX,
          (-0.5 * mouseY) / windowHalfY,
          0
        );

        mouseX = 10000;
        mouseY = 10000;

        gpuCompute.compute();

        birdUniforms["texturePosition"].value =
          gpuCompute.getCurrentRenderTarget(positionVariable).texture;
        birdUniforms["textureVelocity"].value =
          gpuCompute.getCurrentRenderTarget(velocityVariable).texture;

        renderer.render(scene, camera);
      }
    </script>

    <script>
      document
        .querySelector(".logo")
        .addEventListener("pointermove", (event) => {
          const webglContainer = document.querySelector("#webgl-container");
          const newEvent = new PointerEvent(event.type, event);
          webglContainer.dispatchEvent(newEvent);
        });
    </script>

    <!-- Horizontal Scroll -->
    <script>
      /*
            const minScroll = window.innerWidth * 0.1 + window.innerWidth * 0.0486;
            let translate = -minScroll;

            function transformScroll(event) {
              if (!event.deltaY) {
                return;
              }

              translate += (event.deltaY + event.deltaX) / 3;

              translate = Math.max(translate, 0);
              translate = Math.min(translate, window.innerWidth * 3.9);
              console.log(translate);

              //final = Math.max(-minScroll, translate);
              let t = document.getElementById("ticker");
              t.style.transform = `translate(${minScroll}px, ${-translate}px)`;
            }

            var element = document.scrollingElement || document.documentElement;
            element.addEventListener("wheel", transformScroll);
      */
      //document.addEventListener("DOMContentLoaded", function () {

      const minScroll = window.innerWidth * 0.1 + window.innerWidth * 0.0486;
      const tickerContainer = document.getElementById("ticker-container");
      const ticker = document.getElementById("ticker");
      const textSections = Array.from(ticker.getElementsByTagName("p"));
      let currentIndex = 0;
      let lastScrollY = window.scrollY;
      let accumulatedScroll = 0;
      const scrollThreshold = window.innerHeight * 0.2; // 5vh
      //const slideAmount = window.innerHeight * 0.3; // 40vh
      let currentOffset = 0;
      let isAnimating = false;

      textSections.forEach((p, i) => {
        if (i !== 0) p.style.opacity = "0";
        p.style.transition = "opacity 0.6s ease-in-out";
        p.style.position = "absolute";
        //p.style.width = "100%";
      });

      function dotCheck(ind) {
        document.querySelectorAll(".dot-wrap").forEach(function (d) {
          d.classList.remove("mimic-hover");
        
        });
        document.querySelectorAll(".mobile-headers h3").forEach(function(h) {
          h.style.display = 'none';
        });
        if (ind == 1) {
          document.getElementById('mobileAbout').style.display = 'block';
          //document
          //  .querySelector(".dot-wrap.about")
          //  .classList.add("mimic-hover");
        } else if (ind > 1 && ind <= 5) {
          document.getElementById('mobileTestimonials').style.display = 'block';

          //document
          //  .querySelector(".dot-wrap.testimonials")
          //  .classList.add("mimic-hover");
        } else if (ind >= 6) {
          document.getElementById('mobileTalk').style.display = 'block';

          //document.querySelector(".dot-wrap.talk").classList.add("mimic-hover");
        }
      }

      let proceedLoopVar = false;

      function proceedLoop(boolVal) {
        proceedLoopVar = boolVal;
      }

      function navdot(ind) {
        // Fade out the current text
        textSections[currentIndex].style.opacity = "0";

        // Wait for the fade-out to complete (600ms)
        setTimeout(() => {
          // Hide the previous text after fade-out
          textSections[currentIndex].style.display = "none";
          console.log("Old index:", currentIndex);

          // Update to the new index and perform any necessary dot checks
          
          currentIndex = ind;
          
          console.log("New index:", currentIndex);
          console.log("proceed loop", proceedLoopVar);
          dotCheck(currentIndex);

          // Prepare the new text element by displaying it and setting its initial opacity to 0
          textSections[currentIndex].style.display = "block";
          //textSections[currentIndex].style.opacity = "0";
          tickerContainer.style.display = "block";

          // Wait briefly (50ms) before starting the fade-in
          setTimeout(() => {
            textSections[currentIndex].style.opacity = "1";

            // After the fade-in, wait 3 seconds before starting the fade-out of the new text
            if (currentIndex != 6 && currentIndex != 1) {
              setTimeout(() => {
                // Begin fading out the new text
                
                  if (proceedLoopVar == false) {
                    return;
                  }
                  
                textSections[currentIndex].style.opacity = "0";
                

                // Once the fade-out is complete (after 600ms), hide the new text
                setTimeout(() => {
                  textSections[currentIndex].style.display = "none";
                  tickerContainer.style.display = "none";

                  // All animations are now complete. If the condition is met, progress to the next index.
                  if (currentIndex >= 2 && currentIndex < 6) {
                    if (proceedLoopVar == false) {
                      return;
                    }
                    if (currentIndex == 5) {
                      currentIndex = 1;
                    }
                    navdot(parseInt(currentIndex) + 1);
                  } 
                }, 600); // Matches your CSS fade-out duration
              }, 3000);
            } // Wait 3 seconds after fade-in before starting fade-out
          }, 50);
          // Delay to kick off fade-in
        }, 600); // Wait for the initial fade-out to complete
      }
      /*
            function handleScroll(event) {
              if (!event.deltaY) {
                return;
              }





              const scrollY = event.deltaY;
              accumulatedScroll += scrollY / 2;
              console.log(scrollY, lastScrollY, accumulatedScroll);
              if (accumulatedScroll >= scrollThreshold && !isAnimating) {
                console.log("threshold");
                isAnimating = true;
                accumulatedScroll = 0;

                textSections[currentIndex].style.opacity = "0";

                setTimeout(() => {
                  textSections[currentIndex].style.display = "none"; // Hide previous text

                  // Update index
                  if (currentIndex < textSections.length - 1) {
                    currentIndex++;
                  }

                  dotCheck(currentIndex);

                  // Show next text
                  textSections[currentIndex].style.display = "block";
                  textSections[currentIndex].style.opacity = "0"; // Start invisible

                  setTimeout(() => {
                    textSections[currentIndex].style.opacity = "1"; // Fade in
                    isAnimating = false;
                  }, 50);
                }, 600); // Wait for fade-out to complete
              }

              if (accumulatedScroll <= -scrollThreshold && !isAnimating) {

                console.log("neg threshold");
                isAnimating = true;
                accumulatedScroll = 0;

                textSections[currentIndex].style.opacity = "0";

                setTimeout(() => {
                  textSections[currentIndex].style.display = "none"; // Hide previous text

                  // Update index
                  if (currentIndex > 0) {
                    currentIndex--;
                  } else {
                    currentIndex = 0; // Loop back to the first item if at the end
                  }
                  dotCheck(currentIndex);


                  // Show next text
                  textSections[currentIndex].style.display = "block";
                  textSections[currentIndex].style.opacity = "0"; // Start invisible

                  setTimeout(() => {
                    textSections[currentIndex].style.opacity = "1"; // Fade in
                    isAnimating = false;
                  }, 50);
                }, 600); // Wait for fade-out to complete
              }

              lastScrollY = scrollY;
            }
            var element = document.scrollingElement || document.documentElement;
            element.addEventListener("wheel", handleScroll);
            */
      // });
    </script>
  </body>
</html>
